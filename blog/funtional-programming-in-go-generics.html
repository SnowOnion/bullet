
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-FYHS50G6DL"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'G-FYHS50G6DL');
            
        </script>
    <meta property="og:title" content="函数式编程在 Go 泛型下的实用性探索" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://silverrainz.me/blog/funtional-programming-in-go-generics.html" />
<meta property="og:site_name" content="银色子弹" />
<meta property="og:description" content="背景: 函数式编程（Functional Programming / FP）作为一种编程范式，具有无状态、无副作用、并发友好、抽象程度高等优点。目前流行的编程语言（C++、Python、Rust）都或多或少地引入了函数式特性，但在同作为流行语言的 Golang 中却少有讨论。 究其原因，大部分的抱怨 2 3 集中于 Go 缺乏对范型的支持，难以写出类型间通用的函数。代码生成只能解决一部分已知..." />
<meta property="og:image" content="https://silverrainz.me/_static/logo.png" />
<meta property="og:image:alt" content="银色子弹" />
<meta name="description" content="背景: 函数式编程（Functional Programming / FP）作为一种编程范式，具有无状态、无副作用、并发友好、抽象程度高等优点。目前流行的编程语言（C++、Python、Rust）都或多或少地引入了函数式特性，但在同作为流行语言的 Golang 中却少有讨论。 究其原因，大部分的抱怨 2 3 集中于 Go 缺乏对范型的支持，难以写出类型间通用的函数。代码生成只能解决一部分已知..." />

    <title>函数式编程在 Go 泛型下的实用性探索 &#8212; 银色子弹</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-player_2.6.1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/ablog-custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/asciinema-player_2.6.1.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script data-isso="https://comments.silverrainz.me:30500" src="https://comments.silverrainz.me:30500/js/embed.min.js"></script>
    <link rel="canonical" href="https://silverrainz.me/blog/funtional-programming-in-go-generics.html" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="zh_CN">
    

    <!-- Google Analytics -->
     
<link
  rel="alternate"
  type="application/atom+xml"
  href="../blog/atom.xml"
  title="银色子弹"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">银色子弹</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>  
<h2>
   <i class="fa fa-calendar"></i>
  2021-10-27 
</h2>

<ul>
   
<li id="author">
  <span
    ><i class="fa-fw fa fa-user"></i></span
  >
   
  <a href="author/shengyu-zhang.html">Shengyu Zhang</a>  
</li>
  
<li id="language">
  <span
    ><i class="fa-fw fa fa-language"></i></span
  >
   
  <a href="language/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87.html">简体中文</a>  
</li>
  
<li id="tags">
  <span
    ><i class="fa-fw fa fa-tags"></i> </span
  >
   
  <a href="tag/%E6%B3%9B%E5%9E%8B.html">泛型</a>   
  <a href="tag/golang.html">Golang</a>   
  <a href="tag/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html">函数式编程</a>  
</li>
 
</ul>

<h3>
  <a href="../blog.html">Recent Posts</a>
</h3>
<ul>
   
  <li>
    <a href="paper-size.html"
      >26 June - 纸张尺寸标准以及非标准纸张的收纳技巧</a
    >
  </li>
  
  <li>
    <a href="when-go-generics.html"
      >03 June - 何时使用 Go 泛型</a
    >
  </li>
  
  <li>
    <a href="xzzh-after-40-yrs.html"
      >03 July - 四十年后再看西藏组画</a
    >
  </li>
  
  <li>
    <a href="sphinx-as-note-taking-system-2.html"
      >25 May - 我如何用 Sphinx 建立笔记系统（二）系统架构</a
    >
  </li>
  
  <li>
    <a href="sphinx-as-note-taking-system-1.html"
      >24 May - 我如何用 Sphinx 建立笔记系统（一）选择 Sphinx 的理由</a
    >
  </li>
  
</ul>

<h3><a href="tag.html">Tags</a></h3>
<style type="text/css">
  ul.ablog-cloud {
    list-style: none;
    overflow: auto;
  }
  ul.ablog-cloud li {
    float: left;
    height: 20pt;
    line-height: 18pt;
    margin-right: 5px;
  }
  ul.ablog-cloud a {
    text-decoration: none;
    vertical-align: middle;
  }
  li.ablog-cloud-1 {
    font-size: 80%;
  }
  li.ablog-cloud-2 {
    font-size: 95%;
  }
  li.ablog-cloud-3 {
    font-size: 110%;
  }
  li.ablog-cloud-4 {
    font-size: 125%;
  }
  li.ablog-cloud-5 {
    font-size: 140%;
  }
</style>
<ul class="ablog-cloud">
   
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/arch-linux.html">Arch Linux</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/c.html">C</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/ctf.html">CTF</a>
  </li>
      
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/gsoc.html">GSoC</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/gtk.html">GTK</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/golang.html">Golang</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-4">
    <a href="tag/haskell.html">Haskell</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/irc.html">IRC</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/isso.html">Isso</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/linux.html">Linux</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/makefile.html">Makefile</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/os.html">OS</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/python.html">Python</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/reverse.html">Reverse</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-4">
    <a href="tag/sphinx.html">Sphinx</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/srain.html">Srain</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/teeworlds.html">Teeworlds</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/vim.html">Vim</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/windows.html">Windows</a>
  </li>
      
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/restructuredtext.html">reStructuredText</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-5">
    <a href="tag/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html">函数式编程</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%8D%B0%E5%88%B7-%E7%94%BB%E7%94%BB.html">印刷 画画</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%8F%98%E6%9B%B4.html">变更</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%A4%9A%E8%AF%B4.html">多说</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%B1%95%E8%A7%88.html">展览</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/%E6%B3%9B%E5%9E%8B.html">泛型</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%94%9F%E6%B4%BB.html">生活</a>
  </li>
      
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%9E%8E%E6%89%AF.html">瞎扯</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F.html">笔记系统</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%BB%98%E7%94%BB.html">绘画</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%BF%BB%E8%AF%91.html">翻译</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E8%AE%BE%E5%A4%87.html">设备</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E9%99%88%E4%B8%B9%E9%9D%92.html">陈丹青</a>
  </li>
   
</ul>

<h3>
  <a href="category.html">Categories</a>
</h3>
<ul>
   
  <li>
    <a href="category/gsoc-2016.html">GSoc 2016 (2)</a>
  </li>
    
  <li>
    <a href="category/%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A8-sphinx-%E5%BB%BA%E7%AB%8B%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F.html">我如何用 Sphinx 建立笔记系统 (2)</a>
  </li>
   
</ul>

<h3>
  <a href="archive.html">Archives</a>
</h3>
<ul>
   
  <li>
    <a href="2022.html">2022 (2)</a>
  </li>
    
  <li>
    <a href="2021.html">2021 (5)</a>
  </li>
    
  <li>
    <a href="2020.html">2020 (2)</a>
  </li>
    
  <li>
    <a href="2017.html">2017 (2)</a>
  </li>
    
  <li>
    <a href="2016.html">2016 (6)</a>
  </li>
    
  <li>
    <a href="2015.html">2015 (18)</a>
  </li>
   
</ul>
</div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/SilverRainZ/bullet"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   背景
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   概述
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   泛型语法
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id11">
   高阶函数
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id12">
     代码生成之困
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id17">
     无糖的泛型
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id18">
       闭包语法
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id21">
       方法类型参数
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id24">
   惰性求值
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map">
     Map 的迭代器
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id26">
   局部应用
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id28">
     类型参数推导
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id31">
     可变类型参数
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   类型系统
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id34">
     编译期类型判断
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id35">
     无法辨认「基础类型」
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#type-assertion">
     类型约束不可用于 type assertion
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id37">
   总结
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id38">
   参考
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>函数式编程在 Go 泛型下的实用性探索</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   背景
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   概述
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   泛型语法
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id11">
   高阶函数
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id12">
     代码生成之困
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id17">
     无糖的泛型
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id18">
       闭包语法
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id21">
       方法类型参数
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id24">
   惰性求值
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map">
     Map 的迭代器
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id26">
   局部应用
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id28">
     类型参数推导
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id31">
     可变类型参数
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   类型系统
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id34">
     编译期类型判断
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id35">
     无法辨认「基础类型」
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#type-assertion">
     类型约束不可用于 type assertion
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id37">
   总结
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id38">
   参考
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                 <section id="go">
<h1>函数式编程在 Go 泛型下的实用性探索<a class="headerlink" href="#go" title="永久链接至标题">#</a></h1>
<section id="id1">
<h2>背景<a class="headerlink" href="#id1" title="永久链接至标题">#</a></h2>
<p>函数式编程（Functional Programming / FP）作为一种编程范式，具有无状态、无副作用、并发友好、抽象程度高等优点。目前流行的编程语言（C++、Python、Rust）都或多或少地引入了函数式特性，但在同作为流行语言的 Golang 中却少有讨论。</p>
<p>究其原因，大部分的抱怨 <a class="footnote-reference brackets" href="#id40" id="id2">2</a> <a class="footnote-reference brackets" href="#id41" id="id3">3</a> 集中于 Go 缺乏对范型的支持，难以写出类型间通用的函数。代码生成只能解决一部分已知类型的处理，且无法应对类型组合导致复杂度（比如实现一个通用的 TypeA → TypeB 的 map 函数）。</p>
<p>有关泛型的提案 <a class="reference external" href="https://github.com/golang/go/issues/43651">spec: add generic programming using type parameters #43651</a> 已经被 Go 团队接受，并计划在 2022 年初发布支持范型的 Go 1.18，现在 golang/go 仓库的 master 分支已经支持范型。</p>
<blockquote>
<div><p>This design has been proposed and accepted as a future language change. We currently expect that this change will be available in the Go 1.18 release in early 2022. <a class="footnote-reference brackets" href="#id39" id="id4">1</a></p>
</div></blockquote>
<p>基于这个重大特性，我们有理由重新看看，函数式特性在 Go 范型的加持下，能否变得比以往更加实用。</p>
</section>
<section id="id6">
<h2>概述<a class="headerlink" href="#id6" title="永久链接至标题">#</a></h2>
<p>这篇文章里，我们会尝试用 Go 的泛型循序渐进地实现一些常见的函数式特性，从而探索 Go 泛型的优势和不足。</p>
<p>除非额外说明（例如注释中的 <code class="code docutils literal notranslate"><span class="pre">//</span> <span class="pre">INVALID</span> <span class="pre">CODE!!!</span></code>），文章里的代码都是可以运行的（为了缩减篇幅，部分删去了 <code class="code docutils literal notranslate"><span class="pre">package</span> <span class="pre">main</span></code> 声明和 <code class="code docutils literal notranslate"><span class="pre">main</span></code> 函数，请自行添加）。你可以自行 <a class="reference external" href="https://golang.org/doc/install/source#install">从源码编译</a> 一个 master 版本的 go 来提前体验 Go 的泛型，或者用 <a class="reference external" href="https://go2goplay.golang.org/">The go2go Playground</a> 提供的在线编译器运行单个文件。</p>
</section>
<section id="id9">
<h2>泛型语法<a class="headerlink" href="#id9" title="永久链接至标题">#</a></h2>
<p>提案的 <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#very-high-level-overview">#Very high level overview</a> 一节中描述了为范型而添加的新语法，这里简单描述一下阅读本文所需要的语法：</p>
<ul>
<li><p>函数名后可以附带一个方括号，包含了该函数涉及的类型参数（Type Paramters）的列表：<code class="code docutils literal notranslate"><span class="pre">func</span> <span class="pre">F[T</span> <span class="pre">any](p</span> <span class="pre">T)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p></li>
<li><p>这些类型参数可以在函数参数和函数体中（作为类型）被使用</p></li>
<li><p>自定义类型也可以有类型参数列表：<code class="code docutils literal notranslate"><span class="pre">type</span> <span class="pre">M[T</span> <span class="pre">any]</span> <span class="pre">[]T</span></code></p></li>
<li><p>每个类型参数对应一个类型约束，上述的 <code class="code docutils literal notranslate"><span class="pre">any</span></code> 就是预定义的匹配任意类型的约束</p></li>
<li><p>类型约束在语法上以 <code class="code docutils literal notranslate"><span class="pre">interface</span></code> 的形式存在，在 <code class="code docutils literal notranslate"><span class="pre">interface</span></code> 中嵌入类型 <code class="code docutils literal notranslate"><span class="pre">T</span></code> 可以表示这个类型必须是 <code class="code docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Integer1</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>嵌入单个类型意义不大，我们可以用 <code class="code docutils literal notranslate"><span class="pre">|</span></code> 来描述类型的 union:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Integer2</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">int8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">int16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">int64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">~T</span></code> 语法可以表示该类型的「基础类型」是 <code class="code docutils literal notranslate"><span class="pre">T</span></code>，比如说我们的自定义类型 <code class="code docutils literal notranslate"><span class="pre">type</span> <span class="pre">MyInt</span> <span class="pre">int</span></code> 不满足上述的 <code class="code docutils literal notranslate"><span class="pre">Integer1</span></code> 约束，但满足以下的约束:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Integer3</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">~</span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>「基础类型」在提案中为 “underlying type”，目前尚无权威翻译，在本文中使用仅为方便描述。</p>
</div>
</section>
<section id="id11">
<h2>高阶函数<a class="headerlink" href="#id11" title="永久链接至标题">#</a></h2>
<p>在函数式编程语言中，<a class="reference external" href="https://zh.wikipedia.org/wiki/高阶函数">📖 高阶函数</a> （Higher-order function）是一个重要的特性。高阶函数是至少满足下列一个条件的函数：</p>
<ul class="simple">
<li><p>接受一个或多个函数作为输入</p></li>
<li><p>输出一个函数</p></li>
</ul>
<p>Golang 支持闭包，所以实现高阶函数毫无问题:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">bar</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">bar</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">bar</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nx">foobar</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">bar</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">foobar</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// foo bar</span><span class="w"></span>
</pre></div>
</div>
<p>filter 操作是高阶函数的经典应用，它接受一个函数 f（<code class="code docutils literal notranslate"><span class="pre">func</span> <span class="pre">(T)</span> <span class="pre">bool</span></code>）和一个线性表 l（<code class="code docutils literal notranslate"><span class="pre">[]</span> <span class="pre">T</span></code>），对 l 中的每个元素应用函数 f，如结果为 <code class="code docutils literal notranslate"><span class="pre">true</span></code>，则将该元素加入新的线性表里，否则丢弃该元素，最后返回新的线性表。</p>
<p>根据上面的泛型语法，我们可以很容易地写出一个简单的 filter 函数:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Filter</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">f</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">src</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">dst</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">src</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="nx">dst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">dst</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">src</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nx">dst</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">src</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">dst</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// [0 1 2]</span><span class="w"></span>
</pre></div>
</div>
<section id="id12">
<h3>代码生成之困<a class="headerlink" href="#id12" title="永久链接至标题">#</a></h3>
<p>在 1.17 或者更早前的 Go 版本中，要实现通用的 Filter 函数有两种方式：</p>
<ol class="arabic simple">
<li><p>使用 <code class="code docutils literal notranslate"><span class="pre">interface{}</span></code> 配合反射，牺牲一定程度的类型安全和运行效率</p></li>
<li><p>为不同数据类型实现不同的 Filter 变种，例如 <code class="code docutils literal notranslate"><span class="pre">FilterInt</span></code>、<code class="code docutils literal notranslate"><span class="pre">FilterString</span></code> 等，缺点在于冗余度高，维护难度大</p></li>
</ol>
<p>方式 2 的缺点可以通过代码生成规避，具体来说就使用相同的一份模版，以数据类型为变量生成不同的实现。我们在 Golang 内部可以看到不少 <a class="reference external" href="https://github.com/golang/go/search?q=filename%3Agen.go">代码生成的例子</a> 。</p>
<p>那么，有了代码生成，我们是不是就不需要泛型了呢？</p>
<p>答案是否定的：</p>
<ol class="arabic">
<li><p>代码生成只能针对已知的类型生成代码，明明这份模版对 <code class="code docutils literal notranslate"><span class="pre">float64</span></code> 也有效，但作者只生成了处理 <code class="code docutils literal notranslate"><span class="pre">int</span></code> 的版本，我们作为用户无能为力（用 <code class="code docutils literal notranslate"><span class="pre">interface{}</span></code> 同理，我们能使用什么类型，取决于作者列出了多少个 type switch 的 cases）</p>
<p>而在泛型里，新的类型约束语法可以统一地处理「基础类型」相同的所有类型:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">signed</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">~</span><span class="kt">int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">int8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">int16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">int32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">int64</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">float32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">float64</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">complex64</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">complex128</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">Neg</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="nx">signed</span><span class="p">](</span><span class="nx">n</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="nx">n</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">type</span><span class="w"> </span><span class="nx">MyInt</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>

<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Neg</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Neg</span><span class="p">(</span><span class="mf">1.1</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Neg</span><span class="p">(</span><span class="nx">MyInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// -1</span><span class="w"></span>
<span class="c1">// -1.1</span><span class="w"></span>
<span class="c1">// -1</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>代码生成难以应对需要类型组合的场景，我们来看另一个高阶函数 map：接受一个函数 f（<code class="code docutils literal notranslate"><span class="pre">func</span> <span class="pre">(T1)</span> <span class="pre">T2</span></code>）和一个线性表 l1（<code class="code docutils literal notranslate"><span class="pre">[]T1</span></code>），对 l1 中的每个元素应用函数 f，返回的结果组成新的线性表 l2（<code class="code docutils literal notranslate"><span class="pre">[]T2</span></code>）</p>
<p>如果使用代码生成的话，为了避免命名冲突，我们不得不写出 <code class="code docutils literal notranslate"><span class="pre">MapIntInt</span></code>、<code class="code docutils literal notranslate"><span class="pre">MapIntUint</span></code>、<code class="code docutils literal notranslate"><span class="pre">MapIntString</span></code> 这样的奇怪名字，而且由于类型的组合，代码生成的量将大大膨胀。</p>
<p>我们可以发现在现有的支持 FP 特性的 Go library 里：</p>
<ul class="simple">
<li><p>有的（ <a class="reference external" href="https://pkg.go.dev/github.com/DylanMeeus/hasgo/types?utm_source=godoc#Ints.Map">hasgo</a> ）选择将 map 实现成了闭合运算（<code class="code docutils literal notranslate"><span class="pre">[]T</span> <span class="pre">→</span> <span class="pre">[]T</span></code>），牺牲了表达能力</p></li>
<li><p>有的（ <a class="reference external" href="https://pkg.go.dev/github.com/logic-building/functional-go/fp">functional-go</a> ）强行用代码生成导致接口数目爆炸</p></li>
<li><p>有的（ <a class="reference external" href="https://pkg.go.dev/github.com/TeaEntityLab/fpGo#Map">fpGo</a> ）选择牺牲类型安全用 interface{} 实现</p></li>
</ul>
<p>如果使用泛型的话，只需要定义这样的签名就好了:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Map</span><span class="p">[</span><span class="nx">T1</span><span class="p">,</span><span class="w"> </span><span class="nx">T2</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">f</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span><span class="w"> </span><span class="nx">T2</span><span class="p">,</span><span class="w"> </span><span class="nx">src</span><span class="w"> </span><span class="p">[]</span><span class="nx">T1</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="nx">T2</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id17">
<h3>无糖的泛型<a class="headerlink" href="#id17" title="永久链接至标题">#</a></h3>
<p>Go 的语法在一众的编程语言里绝对算不上简洁优雅。在官网上看到操作 channel 时 <code class="code docutils literal notranslate"><span class="pre">&lt;-</span></code> 的直观便捷让你心下暗喜，而一旦你开始写 real world 的代码，这个语言就处处难掩设计上的简陋。泛型即将到来，而这个语言的其他部分似乎没有做好准备：</p>
<section id="id18">
<h4>闭包语法<a class="headerlink" href="#id18" title="永久链接至标题">#</a></h4>
<p>在 Haskell 中的匿名函数形式非常简洁：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="c1">-- Output:</span><span class="w"></span>
<span class="c1">-- [0,1,2]</span><span class="w"></span>
</pre></div>
</div>
<p>而在 Golang 里，函数的类型签名不可省略，无论高阶函数要求何种签名，调用者在构造闭包的时候总是要完完整整地将其照抄一遍 <a class="footnote-reference brackets" href="#id40" id="id19">2</a></p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">bar</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">float64</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">foobar</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="kt">float64</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">        </span><span class="nx">foobar</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这个问题可以归结于 Go 团队为了保持所谓的「大道至简」，而对类型推导这样提升效率降低冗余的特性的忽视（泛型的姗姗来迟又何尝不是如此呢？）。 <a class="reference external" href="https://github.com/golang/go/issues/21498">proposal: Go 2: Lightweight anonymous function syntax #21498</a> 提出了一个简化闭包调用语法的提案，但即使该提案被 accept，我们最快也只能在 Go 2 里见到它了。</p>
</section>
<section id="id21">
<h4>方法类型参数<a class="headerlink" href="#id21" title="永久链接至标题">#</a></h4>
<p><a class="reference external" href="https://wikipedia.org/wiki/Method_chaining">链式调用</a> （Method chaining）是一种调用函数的语法，每个调用都会返回一个对象，紧接着又可以调用该对象关联的方法，该方法同样也返回一个对象。链式调用能显著地消除调用的嵌套，可读性好。我们熟悉的 GORM 的 API 里就大量使用了链式调用:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">db</span><span class="p">.</span><span class="nx">Where</span><span class="p">(</span><span class="s">&quot;name = ?&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;jinzhu&quot;</span><span class="p">).</span><span class="nx">Where</span><span class="p">(</span><span class="s">&quot;age = ?&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">).</span><span class="nx">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>在函数式编程中，每个高阶函数往往只实现了简单的功能，通过它们的组合实现复杂的数据操纵。</p>
<p>在无法使用链式调用的情况下，高阶函数的互相组合是这样子的（这仅仅是两层的嵌套）:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">Map</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}))</span><span class="w"></span>
</pre></div>
</div>
<p>如果用链式调用呢？我们继续沿用前面的 filter ，改成以下形式:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">l</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">dst</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">l</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="nx">dst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T</span><span class="p">](</span><span class="nx">dst</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">l</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="kt">int</span><span class="p">]([]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}).</span><span class="w"></span>
<span class="w">                </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}).</span><span class="w"></span>
<span class="w">                </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// [0 1]</span><span class="w"></span>
</pre></div>
</div>
<p>看起来很美好，但为什么不用 map 操作举例呢？我们很容易写出这样的方法签名:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// INVALID CODE!!!</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">l</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T1</span><span class="p">])</span><span class="w"> </span><span class="nx">Map</span><span class="p">[</span><span class="nx">T2</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">f</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span><span class="w"> </span><span class="nx">T2</span><span class="p">)</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T2</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>很遗憾这样的代码是没法通过编译的，我们会获得以下错误：</p>
<blockquote>
<div><p>invalid AST: method must have no type parameter</p>
</div></blockquote>
<p>提案的 <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods">#No parameterized methods</a> 一节明确表示了方法（method，也就是有 recevier 的函数）不支持单独指定类型参数：</p>
<blockquote>
<div><p>This design does not permit methods to declare type parameters that are specific to the method. The receiver may have type parameters, but the method may not add any type parameters. <a class="footnote-reference brackets" href="#id39" id="id22">1</a></p>
</div></blockquote>
<p>这个决定实际上是个不得已的妥协。假设我们实现了上述的方法，就意味对于一个已经实例化了的 <code class="code docutils literal notranslate"><span class="pre">List[T]</span></code> 对象（比如说 <code class="code docutils literal notranslate"><span class="pre">List[int]</span></code>），它的 <code class="code docutils literal notranslate"><span class="pre">Map</span></code> 方法可能有多个版本：<code class="code docutils literal notranslate"><span class="pre">Map(func</span> <span class="pre">(int)</span> <span class="pre">int)</span> <span class="pre">List[int]</span></code> 或者 <code class="code docutils literal notranslate"><span class="pre">Map(func</span> <span class="pre">(int)</span> <span class="pre">string)</span> <span class="pre">List[string]</span></code>，当用户的代码调用它们时，它们的代码必然在之前的某个时刻生成了，那么应该在什么时候呢？</p>
<ol class="arabic simple">
<li><p>在编译期，更准确地说，在编译的 link 阶段，这需要 linker 去遍历整个 call graph，确定程序中到底使用了几个版本的 <code class="code docutils literal notranslate"><span class="pre">Map</span></code>。问题在于反射（reflection）的存在：用户可以用 <code class="code docutils literal notranslate"><span class="pre">reflect.MethodByName</span></code> 动态地调用对象的方法，所以即使遍历了整个 call graph，我们也无法确保用户的代码到底调用了几个版本的 <code class="code docutils literal notranslate"><span class="pre">Map</span></code></p></li>
<li><p>在运行期，在第一次调用方法时 yield 到 runtime 中，生成对应版本的函数后 resume 回去，这要求 runtime 支持 JIT（Just-in-time compilation），而目前 Go 并不支持，即使未来 JIT 的支持提上日程，这也不是一蹴而就的事情</p></li>
</ol>
<p>综上，Go 团队选择了不支持给 method 指定类型参数，完美了解决这个问题 🎉。</p>
</section>
</section>
</section>
<section id="id24">
<h2>惰性求值<a class="headerlink" href="#id24" title="永久链接至标题">#</a></h2>
<p><a class="reference external" href="https://zh.wikipedia.org/wiki/惰性求值">📖 惰性求值</a> （Lazy Evaluation）是另一个重要的函数式特性，一个不严谨的描述是：在定义运算时候，计算不会发生，直到我们需要这个值的时候才进行。其优点在于能使计算在空间复杂度上得到极大的优化。</p>
<p>下面的代码展示了一个平平无奇的 Add 函数和它的 Lazy 版本，后者在给出加数的时候不会立刻计算，而是返回一个闭包:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">LazyAdd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上面这个例子没有体现出惰性求值节省空间的优点。基于我们之前实现的高阶函数，做以下的运算:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">l</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"></span>
<span class="nx">l</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">l</span><span class="p">)</span><span class="w"></span>
<span class="nx">l</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">l</span><span class="p">)</span><span class="w"></span>
<span class="nx">l</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">l</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>计算过程中会产生 3 个新的长度为 5 的 <code class="code docutils literal notranslate"><span class="pre">[]int</span></code>，空间复杂度为 <span class="math notranslate nohighlight">\(O(3 * N)\)</span>，尽管常数在复杂度分析时经常被省略，但在程序实际运行的时候，这里的 3 就意味着 3 倍的内存占用。</p>
<p>假设这些高阶函数的求值是惰性的，则计算只会在对 <code class="code docutils literal notranslate"><span class="pre">fmt.Println</span></code> 对参数求值的时候发生，元素从原始的 <code class="code docutils literal notranslate"><span class="pre">l</span></code> 中被取出，判断 <code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">v</span> <span class="pre">&gt;</span> <span class="pre">-2</span></code>、<code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">2</span></code>，最后执行 <code class="code docutils literal notranslate"><span class="pre">v</span> <span class="pre">+</span> <span class="pre">1</span></code>，放入新的 <code class="code docutils literal notranslate"><span class="pre">[]int</span></code> 中，空间复杂度依然是 <span class="math notranslate nohighlight">\(O(N)\)</span>，但毫无疑问地我们只使用了一个 <code class="code docutils literal notranslate"><span class="pre">[]int`</span></code>。</p>
<p>泛型的引入对惰性求值的好处有限，大致和前文所述一致，但至少我们可以定义类型通用的 接口了:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 一个适用于线性结构的迭代器接口</span><span class="w"></span>
<span class="kd">type</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">interface</span><span class="p">{</span><span class="w"> </span><span class="nx">Next</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// 用于将任意 slice 包装成 Iter[T]</span><span class="w"></span>
<span class="kd">type</span><span class="w"> </span><span class="nx">SliceIter</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="w">        </span><span class="nx">s</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">IterOfSlice</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">s</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">SliceIter</span><span class="p">[</span><span class="nx">T</span><span class="p">]{</span><span class="nx">s</span><span class="p">:</span><span class="w"> </span><span class="nx">s</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="nx">SliceIter</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span><span class="w"> </span><span class="nx">Next</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nx">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">.</span><span class="nx">i</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="nx">i</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>接着实现惰性版本的 filter:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">filterIter</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">f</span><span class="w">   </span><span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="w">        </span><span class="nx">src</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="nx">filterIter</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span><span class="w"> </span><span class="nx">Next</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">src</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">Filter</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">f</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">src</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">filterIter</span><span class="p">[</span><span class="nx">T</span><span class="p">]{</span><span class="nx">f</span><span class="p">:</span><span class="w"> </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">src</span><span class="p">:</span><span class="w"> </span><span class="nx">src</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>可以看到这个版本的 filter 仅仅返回了一个 <code class="code docutils literal notranslate"><span class="pre">Iter[T]`（`*filterIter[T]</span></code>），实际的运算在 <code class="code docutils literal notranslate"><span class="pre">*filterIter[T].Next()</span></code> 中进行。</p>
<p>我们还需要一个将 <code class="code docutils literal notranslate"><span class="pre">Iter[T]</span></code> 转回 <code class="code docutils literal notranslate"><span class="pre">[]T</span></code> 的函数:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">List</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">src</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="nx">dst</span><span class="w"> </span><span class="p">[]</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">src</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="nx">dst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>最后实现一个和上面等价的运算，但实际的计算工作是在 <code class="code docutils literal notranslate"><span class="pre">List(i)</span></code> 的调用中发生的:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">IterOfSlice</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w"></span>
<span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Filter</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">List</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<section id="map">
<h3>Map 的迭代器<a class="headerlink" href="#map" title="永久链接至标题">#</a></h3>
<p>Golang 中的 Hashmap <code class="code docutils literal notranslate"><span class="pre">map[K]V</span></code> 和 Slice <code class="code docutils literal notranslate"><span class="pre">[]T</span></code> 一样是常用的数据结构，如果我们能将 map 转化为上述的 <code class="code docutils literal notranslate"><span class="pre">Iter[T]</span></code>，那么 map 就能直接使用已经实现的各种高阶函数。</p>
<p><code class="code docutils literal notranslate"><span class="pre">map[K]V</span></code> 的迭代只能通过 <code class="code docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">range</span></code> 进行，我们无法通过常规的手段获得一个 iterator。反射当然可以做到，但 <code class="code docutils literal notranslate"><span class="pre">reflect.MapIter</span></code> 太重了。<a class="reference external" href="https://github.com/modern-go/reflect2">⛺ modern-go/reflect2</a> 提供了一个 <a class="reference external" href="https://pkg.go.dev/github.com/modern-go/reflect2#UnsafeMapIterator">更快的实现</a> ，但已经超出了本文的讨论范围，此处不展开，有兴趣的朋友可以自行研究。</p>
</section>
</section>
<section id="id26">
<h2>局部应用<a class="headerlink" href="#id26" title="永久链接至标题">#</a></h2>
<p><a class="reference external" href="https://wikipedia.org/wiki/Partial_application">局部应用</a> （Partial Application）是一种固定多参函数的部分参数，并返回一个可以接受剩余部分参数的函数的操作。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>局部应用不同于 <a class="reference external" href="https://zh.wikipedia.org/wiki/柯里化">📖 柯里化</a> （Currying） <a class="footnote-reference brackets" href="#id42" id="id27">4</a> ，柯里化是一种用多个单参函数来表示多参函数的技术，在 Go 已经支持多参函数的情况下，本文暂时不讨论 Currying 的实现。</p>
</div>
<p>我们定义一个有返回值的接收单个参数的函数类型:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">FuncWith1Args</span><span class="p">[</span><span class="nx">A</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span><span class="w"> </span><span class="nx">R</span><span class="w"></span>
</pre></div>
</div>
<p>对一个只接受一个参数的函数进行一次 partial application，其实就相当于求值:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="nx">FuncWith1Args</span><span class="p">[</span><span class="nx">A</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">])</span><span class="w"> </span><span class="nx">Partial</span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="nx">A</span><span class="p">)</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>接受两个参数的函数被 partial application 后，一个参数被固定，自然返回一个上述的 <code class="code docutils literal notranslate"><span class="pre">FuncWith1Args</span></code>:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">FuncWith2Args</span><span class="p">[</span><span class="nx">A1</span><span class="p">,</span><span class="w"> </span><span class="nx">A2</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">A1</span><span class="p">,</span><span class="w"> </span><span class="nx">A2</span><span class="p">)</span><span class="w"> </span><span class="nx">R</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="nx">FuncWith2Args</span><span class="p">[</span><span class="nx">A1</span><span class="p">,</span><span class="w"> </span><span class="nx">A2</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">])</span><span class="w"> </span><span class="nx">Partial</span><span class="p">(</span><span class="nx">a1</span><span class="w"> </span><span class="nx">A1</span><span class="p">)</span><span class="w"> </span><span class="nx">FuncWith1Args</span><span class="p">[</span><span class="nx">A2</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">a2</span><span class="w"> </span><span class="nx">A2</span><span class="p">)</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span><span class="w"> </span><span class="nx">a2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>我们来试用一下，将我们之前实现的 filter 包装成一个 <code class="code docutils literal notranslate"><span class="pre">FuncWith2Args</span></code>，从左到右固定两个参数，最后得到结果:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">FuncWith2Args</span><span class="p">[</span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="kt">int</span><span class="p">],</span><span class="w"> </span><span class="nx">Iter</span><span class="p">[</span><span class="kt">int</span><span class="p">]](</span><span class="nx">Filter</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span><span class="w"></span>
<span class="nx">f1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f2</span><span class="p">.</span><span class="nx">Partial</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="nx">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f1</span><span class="p">.</span><span class="nx">Partial</span><span class="p">(</span><span class="nx">IterOfSlice</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}))</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">List</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// [-1 0 1 2]</span><span class="w"></span>
</pre></div>
</div>
<section id="id28">
<h3>类型参数推导<a class="headerlink" href="#id28" title="永久链接至标题">#</a></h3>
<p>我们勉强实现了 partial application，可是把 <code class="code docutils literal notranslate"><span class="pre">Filter</span></code> 转换为 <code class="code docutils literal notranslate"><span class="pre">FuncWith2Args</span></code> 的过程太过繁琐，在上面的例子中，我们把类型参数完整地指定了一遍，是不是重新感受到了 <a class="reference internal" href="#id18">闭包语法</a> 带给你的无奈？</p>
<p>这一次我们并非无能为力，提案中的 <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#type-inference">#Type inference</a> 一节描述了对类型参数推导的支持情况。上例的转换毫无歧义，那我们把类型参数去掉:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// INVALID CODE!!!</span><span class="w"></span>
<span class="nx">f2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">FuncWith2Args</span><span class="p">(</span><span class="nx">Filter</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p>编译器如是抱怨：</p>
<blockquote>
<div><p>cannot use generic type FuncWith2Args without instantiation</p>
</div></blockquote>
<p>提案里的类型参数推导仅针对函数调用，<code class="code docutils literal notranslate"><span class="pre">FuncWith2Args(XXX)</span></code> 虽然看起来像是函数调用语法，但其实是一个类型的实例化，针对类型实例化的参数类型推导（ <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#type-inference-for-composite-literals">#Type inference for composite literals</a> ）还是一个待定的 feature。</p>
<p>如果我们写一个函数来实例化这个对象呢？很遗憾，做不到：我们用什么表示入参呢？只能写出这样「听君一席话，如听一席话」的函数:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Cast</span><span class="p">[</span><span class="nx">A1</span><span class="p">,</span><span class="w"> </span><span class="nx">A2</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">f</span><span class="w"> </span><span class="nx">FuncWith2Args</span><span class="p">[</span><span class="nx">A1</span><span class="p">,</span><span class="w"> </span><span class="nx">A2</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">])</span><span class="w"> </span><span class="nx">FuncWith2Args</span><span class="p">[</span><span class="nx">A1</span><span class="p">,</span><span class="w"> </span><span class="nx">A2</span><span class="p">,</span><span class="w"> </span><span class="nx">R</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">f</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但是它能工作！当我们直接传入 Filter 的时候，编译器会帮我们隐式地转换成一个 <code class="code docutils literal notranslate"><span class="pre">FuncWith2Args[func(int)</span> <span class="pre">bool,</span> <span class="pre">Iter[int],</span> <span class="pre">Iter[int]]</span></code>！同时因为函数类型参数推导的存在，我们不需要指定任何的类型参数了:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Cast</span><span class="p">(</span><span class="nx">Filter</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span><span class="w"></span>
<span class="nx">f1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f2</span><span class="p">.</span><span class="nx">Partial</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="nx">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f1</span><span class="p">.</span><span class="nx">Partial</span><span class="p">(</span><span class="nx">IterOfSlice</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}))</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">List</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// [-1 0 1 2]</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id31">
<h3>可变类型参数<a class="headerlink" href="#id31" title="永久链接至标题">#</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">FuncWith1Args</span></code> 、<code class="code docutils literal notranslate"><span class="pre">FuncWith2Args</span></code> 这些名字让我们有些恍惚，仿佛回到了代码生成的时代。为了处理更多的参数，我们还得写 <code class="code docutils literal notranslate"><span class="pre">FuncWith3Args</span></code>、<code class="code docutils literal notranslate"><span class="pre">FuncWith4Args</span></code>… 吗？</p>
<p>是的， <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#omissions">#Omissions</a> 一节提到：Go 的泛型不支持可变数目的类型参数：</p>
<blockquote>
<div><p>No variadic type parameters. There is no support for variadic type parameters, which would permit writing a single generic function that takes different numbers of both type parameters and regular parameters.</p>
</div></blockquote>
<p>对应到函数签名，我们也没有语法来声明拥有不同类型的可变参数。</p>
</section>
</section>
<section id="id33">
<h2>类型系统<a class="headerlink" href="#id33" title="永久链接至标题">#</a></h2>
<p>众多函数式特性的实现依赖于一个强大类型系统，Go 的类型系统显然不足以胜任，作者不是专业人士，这里我们不讨论其他语言里让人羡慕的类型类（Type Class）、代数数据类型（Algebraic Data Type），只讨论在 Go 语言中引入泛型之后，我们的类型系统有哪些水土不服的地方。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>其实上文的大部分问题都和类型系统息息相关，case by case 的话我们可以列出非常多的问题，因此以下只展示明显不合理那部分。</p>
</div>
<section id="id34">
<h3>编译期类型判断<a class="headerlink" href="#id34" title="永久链接至标题">#</a></h3>
<p>当我们在写一段泛型代码里的时候，有时候会需要根据 <code class="code docutils literal notranslate"><span class="pre">T</span></code> 实际上的类型决定接下来的流程，可 Go 的完全没有提供在编译期操作类型的能力。运行期的 workaround 当然有，怎么做呢：将 <code class="code docutils literal notranslate"><span class="pre">T</span></code> 转化为 <code class="code docutils literal notranslate"><span class="pre">interface{}</span></code>，然后做一次 type assertion:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Foo</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">n</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">n</span><span class="p">).(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// do sth...</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id35">
<h3>无法辨认「基础类型」<a class="headerlink" href="#id35" title="永久链接至标题">#</a></h3>
<p>我们在 <a class="reference internal" href="#id12">代码生成之困</a> 提到过，在类型约束中可以用 <code class="code docutils literal notranslate"><span class="pre">~T</span></code> 的语法约束所有 基础类型为 <code class="code docutils literal notranslate"><span class="pre">T</span></code> 的类型，这是 Go 在语法层面上首次暴露出「基础类型」的概念，在之前我们只能通过 <code class="code docutils literal notranslate"><span class="pre">reflect.(Value).Kind</span></code> 获取。而在 type assertion 和 type switch 里并没有对应的语法处理「基础类型」:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">~</span><span class="kt">int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="kt">uint</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">IsSigned</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="nx">Int</span><span class="p">](</span><span class="nx">n</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">n</span><span class="p">).(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="kt">int</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;signed&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unsigned&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">type</span><span class="w"> </span><span class="nx">MyInt</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="w">        </span><span class="nx">IsSigned</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">IsSigned</span><span class="p">(</span><span class="nx">MyInt</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Output:</span><span class="w"></span>
<span class="c1">// signed</span><span class="w"></span>
<span class="c1">// unsigned</span><span class="w"></span>
</pre></div>
</div>
<p>乍一看很合理，<code class="code docutils literal notranslate"><span class="pre">MyInt</span></code> 确实不是 <code class="code docutils literal notranslate"><span class="pre">int</span></code>。那我们要如何在函数不了解 <code class="code docutils literal notranslate"><span class="pre">MyInt</span></code> 的情况下把它当 <code class="code docutils literal notranslate"><span class="pre">int</span></code> 处理呢？答案是还不能： <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#identifying-the-matched-predeclared-type">#Identifying the matched predeclared type</a> 表示这是个未决的问题，需要在后续的版本中讨论新语法。总之，在 1.18 中，我们是见不到它了。</p>
</section>
<section id="type-assertion">
<h3>类型约束不可用于 type assertion<a class="headerlink" href="#type-assertion" title="永久链接至标题">#</a></h3>
<p>一个直观的想法是单独定义一个 Signed 约束，然后判断 T 是否满足 Signed:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Signed</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">~</span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">IsSigned</span><span class="p">[</span><span class="nx">T</span><span class="w"> </span><span class="nx">Int</span><span class="p">](</span><span class="nx">n</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">n</span><span class="p">).(</span><span class="nx">Signed</span><span class="p">);</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;signed&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unsigned&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但很可惜，类型约束不能用于 type assertion/switch，编译器报错如下：</p>
<blockquote>
<div><p>interface contains type constraints</p>
</div></blockquote>
<p>尽管让类型约束用于 type assertion 可能会引入额外的问题，但牺牲这个支持让 Go 的类型表达能力大大地打了折扣。</p>
</section>
</section>
<section id="id37">
<h2>总结<a class="headerlink" href="#id37" title="永久链接至标题">#</a></h2>
<p>函数式编程的特性不止于此，代数数据类型、引用透明（Referential Transparency）等在本文中都未能覆盖到。
总得来说，Go 泛型的引入：</p>
<ol class="arabic simple">
<li><p>使的部分 <em>函数式特性能以更通用的方式被实现</em></p></li>
<li><p><em>灵活度比代码生成更高</em> ，用法更自然，但细节上的小问题很多</p></li>
<li><p>1.18 的泛型在引入 type paramters 语法之外并没有其他大刀阔斧的改变，导致泛型和这个语言的其他部分显得有些格格不入，也使得泛型的能力受限。 <em>至少在 1.18 里，我们要忍受泛型中存在的种种不一致</em></p></li>
<li><p>受制于 Go 类型系统的表达能力，我们无法表示复杂的类型约束，自然也 <em>无法实现完备的函数式特性</em></p></li>
</ol>
</section>
<section id="id38">
<h2>参考<a class="headerlink" href="#id38" title="永久链接至标题">#</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id39"><span class="brackets">1</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id22">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">Type Parameters Proposal</a></p>
</dd>
<dt class="label" id="id40"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id19">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://hedzr.com/golang/fp/golang-functional-programming-in-brief/">Golang 函数式编程简述</a></p>
</dd>
<dt class="label" id="id41"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><a class="reference external" href="https://www.youtube.com/watch?v=wqs8n5Uk5OM">GopherCon 2020: Dylan Meeus - Functional Programming with Go</a></p>
</dd>
<dt class="label" id="id42"><span class="brackets"><a class="fn-backref" href="#id27">4</a></span></dt>
<dd><p><a class="reference external" href="https://www.uncarved.com/articles/not-currying/">Partial Function Application is not Currying</a></p>
</dd>
</dl>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm docutils">
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
评论</div>
<p class="sd-card-text">如果你有任何意见，请在此评论。
如果你留下了电子邮箱，我可能会通过 <script type="text/javascript">document.write(
    "<n pynff=\"ersrerapr rkgreany\" uers=\"znvygb:pbzzragf\100fvyireenvam\056zr\">pbzzragf\100fvyireenvam\056zr<\057n>".replace(/[a-zA-Z]/g,
        function(c){
            return String.fromCharCode(
                (c<="Z"?90:122)>=(c=c.charCodeAt(0)+13)?c:c-26
            );
        }
    )
);</script> 回复你。</p>
<section data-isso-id="/blog/funtional-programming-in-go-generics" data-title="函数式编程在 Go 泛型下的实用性探索" id="isso-thread"></section></div>
</div>
</section>
</section>

<div class="section">
    

<div class="section">
  <span style="float: left">
     
    <a href="xzzh-after-40-yrs.html">
      <i class="fa fa-arrow-circle-left"></i> 四十年后再看西藏组画
    </a>
    
  </span>
  <span>&nbsp;</span>
  <span style="float: right">
     
    <a href="when-go-generics.html">
      何时使用 Go 泛型 <i
        class="fa fa-arrow-circle-right"
      ></i
      >
    </a>
    
  </span>
</div>
  
</div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Shengyu Zhang<br/>
  
      &copy; Copyright 2020-2022, Shengyu Zhang.<br/>
    Last updated on 2022-11-03.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>