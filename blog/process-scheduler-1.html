
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-FYHS50G6DL"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'G-FYHS50G6DL');
            
        </script>
    
<meta property="og:title" content="用户态进程的简单实现及调度(一)" />
  
<meta property="og:type" content="website" />
  
<meta property="og:url" content="https://silverrainz.me/blog/process-scheduler-1.html" />
  
<meta property="og:site_name" content="银色子弹" />
  
<meta property="og:description" content="自从上次完成了 Minix v1 文件系统的实现 之后, 就开始看 xv6 中进程相关的代码, 并把它抄进 OS67 中, 到今天为止, 总算是完成地差不多了. 进程的实现可能是 xv6 中耦合度最高的一部分, 在完成大部分的代码 (GDT,TSS 的设置, 上下文保存和切换, 虚拟内存映射, 系统调用)之前, 你很难让你的内核跑起来. xv6 已经尽量使用容易理解的方式来书写这些代码了, ..." />
  
<meta property="og:image" content="https://silverrainz.me/_static/logo.png" />
  
<meta property="og:image:alt" content="银色子弹" />
  
    <title>用户态进程的简单实现及调度(一) &#8212; 银色子弹</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-player_2.6.1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinxnotes-strike.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/ablog-custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/asciinema-player_2.6.1.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script data-isso="https://comments.silverrainz.me:30500" src="https://comments.silverrainz.me:30500/js/embed.min.js"></script>
    <link rel="canonical" href="https://silverrainz.me/blog/process-scheduler-1.html" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="zh_CN">
    

    <!-- Google Analytics -->
     
<link
  rel="alternate"
  type="application/atom+xml"
  href="../blog/atom.xml"
  title="银色子弹"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">银色子弹</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>  
<h2>
   <i class="fa fa-calendar"></i>
  2015-09-14 
</h2>

<ul>
   
<li id="author">
  <span
    ><i class="fa-fw fa fa-user"></i></span
  >
   
  <a href="author/shengyu-zhang.html">Shengyu Zhang</a>  
</li>
  
<li id="language">
  <span
    ><i class="fa-fw fa fa-language"></i></span
  >
   
  <a href="language/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87.html">简体中文</a>  
</li>
  
<li id="tags">
  <span
    ><i
      class="fa-fw fa fa-tag"
    ></i
    ></span
  >
   
  <a href="tag/os.html">OS</a>  
</li>
 
</ul>

<h3>
  <a href="../blog.html">Recent Posts</a>
</h3>
<ul>
   
  <li>
    <a href="funtional-programming-in-go-generics.html"
      >27 October - 函数式编程在 Go 泛型下的实用性探索</a
    >
  </li>
  
  <li>
    <a href="xzzh-after-40-yrs.html"
      >03 July - 四十年后再看西藏组画</a
    >
  </li>
  
  <li>
    <a href="sphinx-as-note-taking-system-2.html"
      >25 May - 我如何用 Sphinx 建立笔记系统（二）系统架构</a
    >
  </li>
  
  <li>
    <a href="sphinx-as-note-taking-system-1.html"
      >24 May - 我如何用 Sphinx 建立笔记系统（一）选择 Sphinx 的理由</a
    >
  </li>
  
  <li>
    <a href="new-boy.html"
      >21 March - 嘿，我去 2010</a
    >
  </li>
  
</ul>

<h3><a href="tag.html">Tags</a></h3>
<style type="text/css">
  ul.ablog-cloud {
    list-style: none;
    overflow: auto;
  }
  ul.ablog-cloud li {
    float: left;
    height: 20pt;
    line-height: 18pt;
    margin-right: 5px;
  }
  ul.ablog-cloud a {
    text-decoration: none;
    vertical-align: middle;
  }
  li.ablog-cloud-1 {
    font-size: 80%;
  }
  li.ablog-cloud-2 {
    font-size: 95%;
  }
  li.ablog-cloud-3 {
    font-size: 110%;
  }
  li.ablog-cloud-4 {
    font-size: 125%;
  }
  li.ablog-cloud-5 {
    font-size: 140%;
  }
</style>
<ul class="ablog-cloud">
   
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/arch-linux.html">Arch Linux</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/c.html">C</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/ctf.html">CTF</a>
  </li>
      
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/gsoc.html">GSoC</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/gtk.html">GTK</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/golang.html">Golang</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-4">
    <a href="tag/haskell.html">Haskell</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/irc.html">IRC</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/isso.html">Isso</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/linux.html">Linux</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/makefile.html">Makefile</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/os.html">OS</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-2">
    <a href="tag/python.html">Python</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/reverse.html">Reverse</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-4">
    <a href="tag/sphinx.html">Sphinx</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/srain.html">Srain</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/teeworlds.html">Teeworlds</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/vim.html">Vim</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/windows.html">Windows</a>
  </li>
      
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/restructuredtext.html">reStructuredText</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-5">
    <a href="tag/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html">函数式编程</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%8F%98%E6%9B%B4.html">变更</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%A4%9A%E8%AF%B4.html">多说</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E5%B1%95%E8%A7%88.html">展览</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%94%9F%E6%B4%BB.html">生活</a>
  </li>
      
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%9E%8E%E6%89%AF.html">瞎扯</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-3">
    <a href="tag/%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F.html">笔记系统</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E7%BB%98%E7%94%BB.html">绘画</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E8%AE%BE%E5%A4%87.html">设备</a>
  </li>
    
  <li class="ablog-cloud ablog-cloud-1">
    <a href="tag/%E9%99%88%E4%B8%B9%E9%9D%92.html">陈丹青</a>
  </li>
   
</ul>

<h3>
  <a href="category.html">Categories</a>
</h3>
<ul>
   
  <li>
    <a href="category/gsoc-2016.html">GSoc 2016 (2)</a>
  </li>
    
  <li>
    <a href="category/%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A8-sphinx-%E5%BB%BA%E7%AB%8B%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F.html">我如何用 Sphinx 建立笔记系统 (2)</a>
  </li>
   
</ul>

<h3>
  <a href="archive.html">Archives</a>
</h3>
<ul>
   
  <li>
    <a href="2021.html">2021 (5)</a>
  </li>
    
  <li>
    <a href="2020.html">2020 (2)</a>
  </li>
    
  <li>
    <a href="2017.html">2017 (2)</a>
  </li>
    
  <li>
    <a href="2016.html">2016 (6)</a>
  </li>
    
  <li>
    <a href="2015.html">2015 (18)</a>
  </li>
   
</ul>
</div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/SilverRainZ/bullet"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   特权级转换
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gdt">
   GDT
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#idt">
   IDT
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tss">
   TSS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   两个上下文
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     中断上下文
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     进程上下文
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   虚拟内存映射
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   第一个进程
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     构造
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     运行
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   调度
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#e-n-d">
   E.N.D.
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>用户态进程的简单实现及调度(一)</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   特权级转换
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gdt">
   GDT
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#idt">
   IDT
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tss">
   TSS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   两个上下文
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     中断上下文
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     进程上下文
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   虚拟内存映射
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   第一个进程
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     构造
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     运行
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   调度
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#e-n-d">
   E.N.D.
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                 <section id="id1">
<h1>用户态进程的简单实现及调度(一)<a class="headerlink" href="#id1" title="永久链接至标题">#</a></h1>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>这是一篇迁移自 Jekyll 的文章，如有格式问题，可到 <a class="reference external" href="https://github.com/SilverRainZ/bullet">⛺SilverRainZ/bullet</a> 反馈</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在写这篇的时候, 我发觉我很难在这短短一篇博文里把进程的实现将清楚,
并且可能存在一些理解的偏差, 因此本篇仅供参考, 更加准确的表述,
还请参考 <a class="reference external" href="https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter5.html">第五章 调度 | xv6 中文文档</a></p>
</div>
<p>自从上次完成了 <a class="reference internal" href="minix-v1-file-system.html"><span class="doc">Minix v1 文件系统的实现</span></a> 之后,
就开始看 xv6 中进程相关的代码, 并把它抄进 OS67 中, 到今天为止, 总算是完成地差不多了.</p>
<p>进程的实现可能是 xv6 中耦合度最高的一部分, 在完成大部分的代码
(GDT,TSS 的设置, 上下文保存和切换, 虚拟内存映射, 系统调用)之前,
你很难让你的内核跑起来.</p>
<p>xv6 已经尽量使用容易理解的方式来书写这些代码了, 不过有些地方仍然比较晦涩(对我来说).
希望再这篇文章里能稍微梳理一下.</p>
<blockquote>
<div><p>注意: OS67 并不打算支持多核 CPU, 这极大地降低了实现进程的难度,
不需要考虑由于多核导致的进程间的竞争和同步, 因此 xv6 中关于锁的代码都可以忽略.</p>
</div></blockquote>
<section id="id2">
<h2>特权级转换<a class="headerlink" href="#id2" title="永久链接至标题">#</a></h2>
<p>几个关于特权级的概念:</p>
<ul class="simple">
<li><p>intel 8086 的特权级分为 0 1 2 3 四级, 这里只使用 0 和 3</p></li>
<li><p>DPL: Descriptor Privilege 描述符特权级, 储存在 GDT 或 IDT 描述符中</p></li>
<li><p>CPL: Current Privilege 当前特权级, 储存在 cs 寄存器的低二位</p></li>
<li><p>RPL: Request Privilege 请求特权级, 请求访问的段的描述符的特权级</p></li>
</ul>
</section>
<section id="gdt">
<h2>GDT<a class="headerlink" href="#gdt" title="永久链接至标题">#</a></h2>
<p>这里使用的用户态的特权级为 3, 因此用户态的程序, 其所在的数据段代码段的 DPL,
段寄存器低 2 位的 RPL 都得是 3, 因此设置的 全局段描述符表(GDT) 如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// OS67/kern/gdt.c</span>
<span class="n">gdt_install</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* kernel code segment type: code addr: 0 limit: 4G gran: 4KB sz: 32bit */</span><span class="w"></span>
<span class="n">gdt_install</span><span class="p">(</span><span class="n">SEL_KCODE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">,</span><span class="w"> </span><span class="n">AC_RW</span><span class="o">|</span><span class="n">AC_EX</span><span class="o">|</span><span class="n">AC_DPL_KERN</span><span class="o">|</span><span class="n">AC_PR</span><span class="p">,</span><span class="w"> </span><span class="n">GDT_GR</span><span class="o">|</span><span class="n">GDT_SZ</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* kernel data segment type: data addr: 0 limit: 4G gran: 4KB sz: bit 32bit */</span><span class="w"></span>
<span class="n">gdt_install</span><span class="p">(</span><span class="n">SEL_KDATA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">,</span><span class="w"> </span><span class="n">AC_RW</span><span class="o">|</span><span class="n">AC_DPL_KERN</span><span class="o">|</span><span class="n">AC_PR</span><span class="p">,</span><span class="w"> </span><span class="n">GDT_GR</span><span class="o">|</span><span class="n">GDT_SZ</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* user code segment type: code addr: 0 limit: 4G gran: 4KB sz: 32bit */</span><span class="w"></span>
<span class="n">gdt_install</span><span class="p">(</span><span class="n">SEL_UCODE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">,</span><span class="w"> </span><span class="n">AC_RW</span><span class="o">|</span><span class="n">AC_EX</span><span class="o">|</span><span class="n">AC_DPL_USER</span><span class="o">|</span><span class="n">AC_PR</span><span class="p">,</span><span class="w"> </span><span class="n">GDT_GR</span><span class="o">|</span><span class="n">GDT_SZ</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* user data segment type: data addr: 0 limit: 4G gran: 4KB sz: 32bit */</span><span class="w"></span>
<span class="n">gdt_install</span><span class="p">(</span><span class="n">SEL_UDATA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">,</span><span class="w"> </span><span class="n">AC_RW</span><span class="o">|</span><span class="n">AC_DPL_USER</span><span class="o">|</span><span class="n">AC_PR</span><span class="p">,</span><span class="w"> </span><span class="n">GDT_GR</span><span class="o">|</span><span class="n">GDT_SZ</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>第一二个描述符定义了内核的代码段和数据段, 第三四个描述符定义了用户的代码段和数据段.</p>
<blockquote>
<div><p>注意: 代码段必须是非一致性代码段, 因为一致性代码段对特权级的处理方式不同.</p>
</div></blockquote>
<p>当 GDT 初始化后, 第一二个描述符被使用, 内核跑在特权级为 0 的段上.
那如何让代码从特权级为 0 的段(内核态)转移到特权级为 3 的段(用户态)呢? 用中断.</p>
</section>
<section id="idt">
<h2>IDT<a class="headerlink" href="#idt" title="永久链接至标题">#</a></h2>
<p>为了让用户空间的程序顺利进入内核态, 需要对 中断描述符表(IDT) 做一些设置.</p>
<p>(以下内容摘自 xv6 中文文档, 有小改动)</p>
<p>我们假设一个用户态程序执行<code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code>指令触发中断, 则 CPU 会取得中断号 n, 进行如下步骤:
(由 PIC 或者异常触发的中断不一定如此)</p>
<ol class="arabic simple">
<li><p>从 中断描述符表(IDT) 获得第 n 个描述符</p></li>
<li><p>检查描述符的特权级 DPL 是否 <em>数值上大于等于</em> 当前的特权级 CPL
(即当前段的级别至少要高于要执行的中断的特权级), 是则继续,
否则触发一个通用保护中断(General Protection Fault, int 13)</p></li>
</ol>
<blockquote>
<div><p>通过设置 DPL, 可以限制用户态能用 int 指令触发的中断号, 系统调用的实现即是如此</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>如果目标段描述符的 <code class="code docutils literal notranslate"><span class="pre">RPL</span> <span class="pre">&lt;</span> <span class="pre">CPL</span></code>, 则在 CPU 内部保存<code class="code docutils literal notranslate"><span class="pre">esp</span></code>和<code class="code docutils literal notranslate"><span class="pre">ss</span></code>的值.
这个时候意味这特权级转换要发生了.</p></li>
<li><p>从一个任务状态段(TSS)加载<code class="code docutils literal notranslate"><span class="pre">ssX</span></code>和<code class="code docutils literal notranslate"><span class="pre">espX</span></code>, X 是 RPL 的值, 所以对于系统调用,
取出的会是 <code class="code docutils literal notranslate"><span class="pre">ss0</span></code>和<code class="code docutils literal notranslate"><span class="pre">esp0</span></code></p></li>
<li><p>将<code class="code docutils literal notranslate"><span class="pre">ss</span></code> <code class="code docutils literal notranslate"><span class="pre">esp</span></code> <code class="code docutils literal notranslate"><span class="pre">eflags</span></code> <code class="code docutils literal notranslate"><span class="pre">cs</span></code> <code class="code docutils literal notranslate"><span class="pre">eip</span></code>压栈</p></li>
<li><p>清除<code class="code docutils literal notranslate"><span class="pre">eflags</span></code>中的某些位</p></li>
<li><p>设置<code class="code docutils literal notranslate"><span class="pre">cs</span></code>和<code class="code docutils literal notranslate"><span class="pre">ip</span></code>为 IDT[n] 中指定的值. (执行中断服务例程)</p></li>
</ol>
<p>对于普通的中断, 其中断返回地址是发生中断时的执行的那条指令的地址
(需要将 IDT 的类型设置为 中断门(Interrupt gate))
因为这种中断通常和当前进程没有什么关系.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">idt_install</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">fault0</span><span class="p">,</span><span class="w"> </span><span class="n">SEL_KCODE</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GATE_INT</span><span class="p">,</span><span class="w"> </span><span class="n">IDT_PR</span><span class="o">|</span><span class="n">IDT_DPL_KERN</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>对于系统调用, 我们需要主动执行 int 指令, 并让其返回到下一条指令处.
因此要将处理系统调用的 IDT 设置为 陷阱门(Trap gate), 并且 DPL 为<code class="code docutils literal notranslate"><span class="pre">IDT_DPL_USER</span></code>(3).
如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">idt_install</span><span class="p">(</span><span class="n">ISR_SYSCALL</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">_syscall</span><span class="p">,</span><span class="w"> </span><span class="n">SEL_KCODE</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GATE_TRAP</span><span class="p">,</span><span class="w"> </span><span class="n">IDT_PR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IDT_DPL_USER</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="tss">
<h2>TSS<a class="headerlink" href="#tss" title="永久链接至标题">#</a></h2>
<p>在特权级转换的时候, 需要从任务状态段取出<code class="code docutils literal notranslate"><span class="pre">ss0</span></code>和<code class="code docutils literal notranslate"><span class="pre">esp0</span></code>, 因此在转换之前需要设置 TSS.</p>
<p>CPU 会从寄存器<code class="code docutils literal notranslate"><span class="pre">tr</span></code>获得 TSS 的选择子, 然后从 GDT 表里面找出对应的描述符,
由描述符就可以获得 TSS 的基址了.</p>
<p>TSS 的选择子放在 GDT 里, 但是其<code class="code docutils literal notranslate"><span class="pre">AC_RE</span></code>(ACCESS_REVERSE)位为 0 来表示
它是一个 TSS 描述符而不是 GDT 描述符.</p>
<p>因此 TSS 的初始化是这样的:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tss_init</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">gdt_install</span><span class="p">(</span><span class="n">SEL_TSS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tss</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tss</span><span class="p">),</span><span class="n">AC_PR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">AC_AC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">AC_EX</span><span class="p">,</span><span class="w"> </span><span class="n">GDT_GR</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* for tss, access_reverse bit is 1 */</span><span class="w"></span>
<span class="w">    </span><span class="n">gdt</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">access</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">AC_RE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在从进程的内核态回到用户态的时候, 要设置一次 TSS, 以下函数在<code class="code docutils literal notranslate"><span class="pre">uvm_switch</span></code>里面被调用:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tss_set</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">ss0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">esp0</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tss</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tss</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">tss</span><span class="p">.</span><span class="n">ss0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ss0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tss</span><span class="p">.</span><span class="n">esp0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">esp0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tss</span><span class="p">.</span><span class="n">iopb_off</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tss</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id3">
<h2>两个上下文<a class="headerlink" href="#id3" title="永久链接至标题">#</a></h2>
<section id="id4">
<h3>中断上下文<a class="headerlink" href="#id4" title="永久链接至标题">#</a></h3>
<p>从上面关于中断过程的解释可以看到, 从用户态执行中断转入内核态是可能的,
重点在与设置一个 DPL = 3 的 IDT 和一个 TSS 段.</p>
<p>那如何从内核态返回用户态呢? iret 指令会按 int 压栈的顺序逆序将寄存器们出栈,
程序就会从内核态又返回到用户态了.</p>
<p>有意思的地方就是, 要从内核态到用户态, 我们可以构造一个栈, 然后执行 iret 指令,
iret 就会将我们特地安排的值覆盖到寄存器上, 这个工作由<code class="code docutils literal notranslate"><span class="pre">proc_alloc</span></code>完成,
每个新建的进程都通过这种方式”假装回到”用户空间.</p>
<p>为了方便地构造栈, 我们需要定义出中断时保存的上下文, int 指令保存的信息还不够,
我们需要自己保存更多的寄存器:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">int_frame</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* segment registers */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">gs</span><span class="p">;</span><span class="w">    </span><span class="c1">// 16 bits</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">fs</span><span class="p">;</span><span class="w">    </span><span class="c1">// 16 bits</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">es</span><span class="p">;</span><span class="w">    </span><span class="c1">// 16 bits</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ds</span><span class="p">;</span><span class="w">    </span><span class="c1">// 16 bits</span>

<span class="w">    </span><span class="cm">/* registers save by pusha */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">edi</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">esi</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ebp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">esp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ebx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">edx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ecx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eax</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">int_no</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* save by `int` instruction */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">err_code</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cs</span><span class="p">;</span><span class="w">    </span><span class="c1">// 16 bits</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eflags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">user_esp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ss</span><span class="p">;</span><span class="w">    </span><span class="c1">// 16 bits</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>只要完整地保存了以上信息并正确还原, 就能确保从中断返回时, 程序依然正常运行.
注意的是我们不必显式地建立以上的一个结构体(构建第一个进程的时候除外), 在中断发生时,
这个结构体会在进程的内核栈上被建立.中断返回时, 这些信息又会从栈里被弹出.</p>
<p>中断上下文的<code class="code docutils literal notranslate"><span class="pre">err_code</span></code>到<code class="code docutils literal notranslate"><span class="pre">ss</span></code>部分由 int 指令压入, 之后跳转到<code class="code docutils literal notranslate"><span class="pre">OS67/kern/loader.asm</span></code>
中的由汇编编写的中断服务例程(ISR)入口. 有的中断不产生<code class="code docutils literal notranslate"><span class="pre">err_code</span></code>,
就由该中断入口压入一个假的<code class="code docutils literal notranslate"><span class="pre">err_code</span></code>. 这些入口代码有两个宏生成,
分别是<code class="code docutils literal notranslate"><span class="pre">m_fault</span></code>和<code class="code docutils literal notranslate"><span class="pre">m_irq</span></code>, 负责处理异常中断和硬件中断.
另外还有<code class="code docutils literal notranslate"><span class="pre">_syscall</span></code>和<code class="code docutils literal notranslate"><span class="pre">_isr_unknown</span></code>处理系统调用和未定义的中断.</p>
<p>每个入口都会压入自己的中断号, 然后统一跳转到<code class="code docutils literal notranslate"><span class="pre">_isr_stub</span></code>, 压入上下文的剩余部分,
再调到由 C 编写的<code class="code docutils literal notranslate"><span class="pre">isr_stub</span></code>, 由此再根据入口压入中断号调用真正的 ISR.
关于这些 ISR 的详情…太长了表示扯不下去了… :(</p>
</section>
<section id="id5">
<h3>进程上下文<a class="headerlink" href="#id5" title="永久链接至标题">#</a></h3>
<p>中断上下文已经让程序能够程序成功进入内核并从内核中返回,
接下来通过切换进程上下文来实现进程的切换.</p>
<p>进程上下文看起来比中断上下文简单许多, 不过更富技巧性.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">context</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">edi</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">esi</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ebx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ebp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>这个上下文同样是建立在进程的内核栈上的,但是内核原来的栈也保存了一个.</p>
<p>我们用下面这个函数来切换进程上下文:</p>
<div class="highlight-objdump-nasm notranslate"><div class="highlight"><pre><span></span><span class="x">; context_switch(struct context **old, context *new)</span>
<span class="x">; 当你调用这个函数时, 会依次 压入 new, old 和 eip</span>
<span class="x">[global context_switch]</span>
<span class="x">context_switch:</span>
<span class="x">    mov eax, [esp + 4]  ; 把 old 放到 eax</span>
<span class="x">    mov edx, [esp + 8]  ; 把 new 放到 edx</span>

<span class="x">    ; 这里已经隐式地保存了 eip</span>
<span class="x">    push ebp</span>
<span class="x">    push ebx</span>
<span class="x">    push esi</span>
<span class="x">    push edi</span>
<span class="x">; 此时的栈结构就是一个 `strcut context`</span>

<span class="x">    mov [eax], esp      ; 把 esp 保存到 old 指向的地址</span>
<span class="x">    mov esp, edx        ; 切换到 new 指向的地址作为栈</span>

<span class="x">    pop edi</span>
<span class="x">    pop esi</span>
<span class="x">    pop ebx</span>
<span class="x">    pop ebp</span>
<span class="x">    ; 还剩下一个 eip 未弹出, 刚好由 ret 弹出, 这样就切换到了 new 里面的 eip</span>
<span class="x">    ret</span>
</pre></div>
</div>
<p>这里的 <code class="code docutils literal notranslate"><span class="pre">eip</span></code> 和 <code class="code docutils literal notranslate"><span class="pre">esp</span></code> 的保存都非常巧妙, eip 在执行 <code class="code docutils literal notranslate"><span class="pre">context_switch</span></code> 时被压入,
又在 <code class="code docutils literal notranslate"><span class="pre">ret</span></code> 的时候被弹出. 而 <code class="code docutils literal notranslate"><span class="pre">esp</span></code> 则直接作为 <code class="code docutils literal notranslate"><span class="pre">context</span></code> 的地址被保存.</p>
<p>可以看到这个函数可以切换当前的执行流到另一个执行流, 进程的切换就是这样实现的,
当然要切换的不止这个, 页表也要切换, 代表当前执行进程的 <code class="code docutils literal notranslate"><span class="pre">proc</span></code> 变量也要更新.
页表的切换由 <code class="code docutils literal notranslate"><span class="pre">uvm_switch</span></code> 执行, <code class="code docutils literal notranslate"><span class="pre">proc</span></code> 的更新则在 <code class="code docutils literal notranslate"><span class="pre">scheduler</span></code> 执行.</p>
</section>
</section>
<section id="id6">
<h2>虚拟内存映射<a class="headerlink" href="#id6" title="永久链接至标题">#</a></h2>
<p>由于之前的思路问题, 因此 OS67 的内存管理方式不得不和 xv6 不太一样.</p>
<p>OS67 的内存分配实现在 <code class="code docutils literal notranslate"><span class="pre">OS67/mm/pmm.c</span></code>, 使用一个简单的栈来存放未分配的内存页,
<code class="code docutils literal notranslate"><span class="pre">malloc</span></code> 就是 <code class="code docutils literal notranslate"><span class="pre">pop</span></code> 而 <code class="code docutils literal notranslate"><span class="pre">mfree</span></code> 就是 <code class="code docutils literal notranslate"><span class="pre">push</span></code>. 这么做简单明了,
虽然申请多个页的时候效率不高, 不过我们不考虑这种需要大量内存的情况.</p>
<p>对于虚拟内存映射, 策略是这样的: 内核以及未分配的内存的虚拟地址和物理地址一一对应,
用户地址映射到 0xc0000000 上. 内核在初始化页表的时候, 建立一个映射所有物理内存的页表,
之后建立的进程页表中的内核部分就复用内核页表的页表项, 避免内存浪费,
同时在特权级转换时也不必切换页表, 亦能很方便地从内核空间访问到用户空间的内存.</p>
<p>将用户地址映射到 0xc0000000 的好处是不需要在建立正式页表前建立临时页表来把内核映射到高处,
另外 <code class="code docutils literal notranslate"><span class="pre">malloc</span></code> 出来的是物理地址, 可以直接对其读写而不必做转换.
缺点则是程序必须经过重定位(链接时使用参数 <code class="code docutils literal notranslate"><span class="pre">-Ttext</span> <span class="pre">0xc0000000</span></code>)才能运行在高地址,
也许有更多的缺点还没发现.</p>
</section>
<section id="id7">
<h2>第一个进程<a class="headerlink" href="#id7" title="永久链接至标题">#</a></h2>
<section id="id8">
<h3>构造<a class="headerlink" href="#id8" title="永久链接至标题">#</a></h3>
<p>结构体 proc 用来储存一个进程的信息, 内核中有一个数组<code class="code docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ptable[NPROC]</span></code>来管理所有的进程.
结构体<code class="code docutils literal notranslate"><span class="pre">proc</span></code>定义如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">killed</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="n">NAME_LEN</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// context</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">int_frame</span><span class="w"> </span><span class="o">*</span><span class="n">fm</span><span class="p">;</span><span class="w">       </span><span class="c1">// 中断上下文</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">context</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">;</span><span class="w">    </span><span class="c1">// 进程上下文</span>

<span class="w">    </span><span class="n">pde_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdir</span><span class="p">;</span><span class="w">               </span><span class="c1">// 进程页表</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">kern_stack</span><span class="p">;</span><span class="w">           </span><span class="c1">// 内核栈</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">chan</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">cwd</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>这里主要关注的是两个上下文, 进程页表以及内核栈.</p>
<p>这里涉及的代码都在<code class="code docutils literal notranslate"><span class="pre">OS37/proc/proc.c</span></code>中.</p>
<p>第一个进程需要手动创建, 由<code class="code docutils literal notranslate"><span class="pre">proc_init</span></code>完成.</p>
<p><code class="code docutils literal notranslate"><span class="pre">proc_inint</span></code>首先调用<code class="code docutils literal notranslate"><span class="pre">proc_alloc</span></code>从<code class="code docutils literal notranslate"><span class="pre">ptable</span></code>获得一个空的进程结构体槽位,
<code class="code docutils literal notranslate"><span class="pre">proc_alloc</span></code>做了一些必要的初始化操作.</p>
<p><code class="code docutils literal notranslate"><span class="pre">proc_alloc</span></code>为新进程申请了内核栈, 并对他进行了一定的构造:</p>
<ul class="simple">
<li><p>为中断上下文<code class="code docutils literal notranslate"><span class="pre">fm</span></code>留出空间, 并把<code class="code docutils literal notranslate"><span class="pre">proc-&gt;fm</span></code>指向该空间.</p></li>
<li><p>在<code class="code docutils literal notranslate"><span class="pre">fm</span></code>之后放置了指向中断返回函数<code class="code docutils literal notranslate"><span class="pre">_isr_stub_ret</span></code>的指针</p></li>
<li><p>为进程上下文<code class="code docutils literal notranslate"><span class="pre">context</span></code>留出空间, 并把<code class="code docutils literal notranslate"><span class="pre">proc-&gt;content</span></code>改空间,</p></li>
<li><p>把<code class="code docutils literal notranslate"><span class="pre">proc-&gt;context-eip</span></code>指向了函数<code class="code docutils literal notranslate"><span class="pre">fork_ret</span></code>.</p></li>
</ul>
<p>在 xv6 中<code class="code docutils literal notranslate"><span class="pre">fork_ret</span></code>被用来处理锁, 这 OS67 中, 这个函数碰巧被用来解决一个
奇怪的 bug &lt;<a class="reference external" href="https://github.com/SilverRainZ/OS67/commit/fc0e84caa1c3ae95998342f2b03125e2226d0dd6">https://github.com/SilverRainZ/OS67/commit/fc0e84caa1c3ae95998342f2b03125e2226d0dd6</a>&gt;`_ .
因此, 正常 alloc 出来的新进程都会返回到<code class="code docutils literal notranslate"><span class="pre">fork_ret</span></code>. 从<code class="code docutils literal notranslate"><span class="pre">fork_ret</span></code>返回后,
又会跳转到<code class="code docutils literal notranslate"><span class="pre">_isr_stub_ret</span></code>准备从中断返回. 接下来就会逐步把<code class="code docutils literal notranslate"><span class="pre">fm</span></code>弹出,
尽管此时的<code class="code docutils literal notranslate"><span class="pre">fm</span></code>还没有初始化.</p>
<p>之后<code class="code docutils literal notranslate"><span class="pre">proc_init</span></code>为第一个进程申请了一个页目录<code class="code docutils literal notranslate"><span class="pre">proc-&gt;pgdir</span></code>,
调用<code class="code docutils literal notranslate"><span class="pre">kvm_init</span></code>建立到内核的一对一的地址映射. 为之前的内核栈也建立地址映射.</p>
<p>再接着, 通过声明在用户程序<code class="code docutils literal notranslate"><span class="pre">OS67/proc/init.asm</span></code>中的全局变量<code class="code docutils literal notranslate"><span class="pre">__init_start</span></code> <code class="code docutils literal notranslate"><span class="pre">__init_end</span></code>
的地址获得编译进内核里的用户程序的位置, 调用<code class="code docutils literal notranslate"><span class="pre">uvm_init_fst</span></code>把程序复制到一个新的页中,
并把该页映射到<code class="code docutils literal notranslate"><span class="pre">USER_BASE</span></code>(0xc0000000).</p>
<p>然后开始手动构建一个<code class="code docutils literal notranslate"><span class="pre">fm</span></code>, 为各个段寄存器设置正确的段选择子,
为 eflags 寄存器加上 IF 标志(允许中断), 设置用户栈, 最后把<code class="code docutils literal notranslate"><span class="pre">eip</span></code>设定为<code class="code docutils literal notranslate"><span class="pre">USER_BASE</span></code>.</p>
<p>最后把进程的状态<code class="code docutils literal notranslate"><span class="pre">proc-&gt;state</span></code>设置为可运行 <code class="code docutils literal notranslate"><span class="pre">P_RUNABLE</span></code>.</p>
<p>以上是比较关键的步骤, 现在可以准备运行第一个进程了.</p>
</section>
<section id="id9">
<h3>运行<a class="headerlink" href="#id9" title="永久链接至标题">#</a></h3>
<p>执行了<code class="code docutils literal notranslate"><span class="pre">proc_init</span></code>之后, <code class="code docutils literal notranslate"><span class="pre">scheduler</span></code>紧接其后,
它在<code class="code docutils literal notranslate"><span class="pre">ptable</span></code>中寻找第一个<code class="code docutils literal notranslate"><span class="pre">state</span></code>为<code class="code docutils literal notranslate"><span class="pre">P_RUNABLE</span></code>的进程,
调用<code class="code docutils literal notranslate"><span class="pre">uvm_switch</span></code>切换到该进程的页表并设置好 TSS.</p>
<p>接着更新<code class="code docutils literal notranslate"><span class="pre">proc</span></code>变量, 把<code class="code docutils literal notranslate"><span class="pre">proc-&gt;state</span></code>设置为<code class="code docutils literal notranslate"><span class="pre">P_RUNNING</span></code>.
最后调用<code class="code docutils literal notranslate"><span class="pre">context_switch</span></code>切换到进程.  不出意外的话,
<code class="code docutils literal notranslate"><span class="pre">context_switch</span></code>会弹出<code class="code docutils literal notranslate"><span class="pre">proc-&gt;context</span></code>中设定好的寄存器,
新进程返回到<code class="code docutils literal notranslate"><span class="pre">fork_ret</span></code>之后返回到<code class="code docutils literal notranslate"><span class="pre">_isr_stub_ret</span></code>中, 又把<code class="code docutils literal notranslate"><span class="pre">proc-&gt;fm</span></code>弹出.
于是第一个进程就成功运行在 0xc0000000 的用户空间上了.</p>
</section>
</section>
<section id="id10">
<h2>调度<a class="headerlink" href="#id10" title="永久链接至标题">#</a></h2>
<p>这里使用非常简单的轮转法, 每次触发时钟中断都会执行<code class="code docutils literal notranslate"><span class="pre">sched</span></code>,
<code class="code docutils literal notranslate"><span class="pre">sched</span></code>把当前进程状态由<code class="code docutils literal notranslate"><span class="pre">P_RUNNING</span></code>变更为<code class="code docutils literal notranslate"><span class="pre">P_RUNABLE</span></code>. 接着执行<code class="code docutils literal notranslate"><span class="pre">context_switch</span></code>.
这样 CPU 执行流就回到了刚才<code class="code docutils literal notranslate"><span class="pre">scheduler</span></code>中的循环,
<code class="code docutils literal notranslate"><span class="pre">scheduler</span></code>继续寻找一个<code class="code docutils literal notranslate"><span class="pre">P_RUNABLE</span></code>的进程并切换到它.</p>
</section>
<section id="e-n-d">
<h2>E.N.D.<a class="headerlink" href="#e-n-d" title="永久链接至标题">#</a></h2>
<p>至此, 用户级进程已经成功实现并且被调度. 但是没有有效的接口来启动更多的进程.
我们需要实现一些系统调用比如<code class="code docutils literal notranslate"><span class="pre">fork</span></code>和<code class="code docutils literal notranslate"><span class="pre">exec</span></code>来做这些事情.
:( 但是我已经写不下去了… 如果可以话下次再写吧.</p>
<p><span class="sphinxnotes-strike">不一定有下次</span></p>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm docutils">
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
评论</div>
<p class="sd-card-text">如果你有任何意见，请在此评论。
如果你留下了电子邮箱，我可能会通过 <script type="text/javascript">document.write(
    "<n pynff=\"ersrerapr rkgreany\" uers=\"znvygb:pbzzragf\100fvyireenvam\056zr\">pbzzragf\100fvyireenvam\056zr<\057n>".replace(/[a-zA-Z]/g,
        function(c){
            return String.fromCharCode(
                (c<="Z"?90:122)>=(c=c.charCodeAt(0)+13)?c:c-26
            );
        }
    )
);</script> 回复你。</p>
<section data-isso-id="/blog/process-scheduler-1" data-title="用户态进程的简单实现及调度(一)" id="isso-thread"></section></div>
</div>
</section>
</section>

<div class="section">
    

<div class="section">
  <span style="float: left">
     
    <a href="flag.html">
      <i class="fa fa-arrow-circle-left"></i> 立 Flag
    </a>
    
  </span>
  <span>&nbsp;</span>
  <span style="float: right">
     
    <a href="2015-huashangctf-re300.html">
      2015 华山杯 CTF Reverse 300 <i
        class="fa fa-arrow-circle-right"
      ></i
      >
    </a>
    
  </span>
</div>
  
</div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Shengyu Zhang<br/>
  
      &copy; Copyright 2020-2022, Shengyu Zhang.<br/>
    Last updated on 2022-05-21.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>